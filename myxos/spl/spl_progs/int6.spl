// int=6 holds SysCall 9

alias physicalSP S0;					// Physical Address = Physical Page Number x 512 + offset.
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);

alias sysCallNo S1;						// First argument from stack is system call number.
sysCallNo = [physicalSP - 1];

alias filename S2;
filename = [physicalSP-3];

if (sysCallNo == 9) then				// sysCallNo = 8 => Exec
	alias FATIndex S3;
	FATIndex = 0;

	while (l < 64) do 					// search for file in FAT. 
		if ([FAT + FATIndex*8] == filename) then
			break;
		endif;
		FATIndex = FATIndex + 1;
	endwhile;
	if (FATIndex == 64) then			// if not found, 
		[physicalSP-2] = -1;			// return errorcode
		ireturn;
	endif;

	load (1, [FAT + FATIndex*8 + 2]);
	alias BBIndex S4;
	BBIndex = 0;

	while (BBIndex < 256) do 			// count number of valid pages. 
		if ([SCRATCHPAD + BBIndex] < 0) then
			break;
		endif;
		BBIndex = BBIndex + 1;
	endwhile;
	if (BBIndex >= 3) then				// file too big. 
		[physicalSP-2] = -1;
		ireturn;
	endif;

	alias PTIndex S5;
	PTIndex = 0;
	while([PTBR + 2*PTIndex] >= 0 && PTIndex < 3) do 		// number of entried
		PTIndex = PTIndex + 1;								// in Page table
	endwhile;
	while (PTIndex > BBIndex) do 							// If more than required blocks,
		[MEM_LIST + [PTBR + 2*PTIndex]] = 0;				// unallocate the extras
		[PTBR + 2*PTIndex] = -1;
		[PTBR + 2*PTIndex + 1] = "00";
		PTIndex = PTIndex - 1;
	endwhile;
	while (PTIndex < BBIndex) do 							// else if less, 
		alias counter S1;
		counter = 0;
		while (counter < 64) do 							// find new free ones
			if ([MEM_LIST + counter] == 0) then
				[MEM_LIST + counter] == 1;					// and allocate to page table
				[PTBR + 2*PTIndex] = counter;				
				[PTBR + 2*PTIndex + 1] = "01";
				PTIndex = PTIndex + 1;
				break;
			endif;
			counter = counter + 1;
		endwhile;	
		if (counter == 64) then								// If not enough memory, return error
			[physicalSP-2] = -1;
			ireturn;
		endif;
	endwhile;

	BBIndex = 0;
	counter = 0;
	while ([SCRATCHPAD + BBIndex] > 0 && BBIndex < 256) do							// search in basic block 
		if([SCRATCHPAD + BBIndex] > 23 && [SCRATCHPAD + BBIndex] < 448) then		// for valid code blocks
			while (counter < 3) do 							// in page table
				if ([PTBR + 2*counter] != -1) then			// we go only upto code blocks
					load([PTBR + 2*counter + 1], [SCRATCHPAD + BBIndex]);
					[PTBR + 2*counter + 1] = "01";			// and load the code blocks 
					counter = counter + 1;					// from memory appropriately.
					break;
				endif;
				counter = counter + 1;
			endwhile;
		endif;
		BBIndex = BBIndex + 1;
	endwhile;

	[PTBR + 7] = "01";										// set stack as not referenced.
	alias currPCB S6;
	currPCB = READY_LIST + (PTBR - 1024)*4;
	counter = 0;
	while(counter < 8) do 
		if([currPCB + 15 + 2*counter] != -1) then			// close all files opened by current process
			[FILE_TABLE + [currPCB + 15 + 2*counter]+1] = [FILE_TABLE + [currPCB + 15 + 2*counter]+1] - 1;
			if([FILE_TABLE+[currPCB+15+2*counter]+1]==0) then 
				[FILE_TABLE + [currPCB + 15 + 2*counter]] = -1;
			endif;
			[currPCB+15+2*counter] = -1;
			[currPCB=15+2*counter+1] = 0;					// similar to what we've done in 
		endif;												// file closing
		counter = counter + 1;
	endwhile;

	SP = 3*512;
	alias newPhysicalSP S7;

	newPhysicalSP = ([PTBR+6]);								// new physical sp is reset to base

	[newPhysicalSP] = 0;									// pust IP in stack's top
	ireturn;
endif;