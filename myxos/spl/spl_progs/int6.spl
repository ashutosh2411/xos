// int=6 holds SysCall 9

alias physicalSP S0;					// Physical Address = Physical Page Number x 512 + offset.
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);

alias sysCallNo S1;						// First argument from stack is system call number.
sysCallNo = [physicalSP - 1];

alias currPCB S6;
currPCB = READY_LIST + (PTBR - 1024)*4;
	
if (sysCallNo == 9) then				// sysCallNo = 9 => Exec
	alias filename S2;
	filename = [physicalSP-3];

	alias FATIndex S3;
	FATIndex = 0;

	while (FATIndex < 64) do 			// search for file in FAT. 
		if ([FAT + FATIndex*8] == filename) then
			break;
		endif;
		FATIndex = FATIndex + 1;
	endwhile;
	if (FATIndex == 64) then			// if not found, 
		[physicalSP-2] = -1;			// return errorcode
		ireturn;
	endif;

	load (1, [FAT + FATIndex*8 + 2]);
	alias BBIndex S4;
	BBIndex = 0;

	while (BBIndex < 256) do 			// count number of valid pages. 
		if ([SCRATCHPAD + BBIndex] < 0) then
			break;
		endif;
		BBIndex = BBIndex + 1;
	endwhile;
	if (BBIndex > 3) then				// file too big. 
		[physicalSP-2] = -1;
		ireturn;
	endif;

	alias PTIndex S5;
	PTIndex = 0;
	while([PTBR + 2*PTIndex] >= 0 && PTIndex < 3) do 		// number of entried
		PTIndex = PTIndex + 1;								// in Page table except the 4th one. 
	endwhile;
	while (PTIndex > BBIndex) do 							// If more than required blocks,
		[MEM_LIST + [PTBR + 2*PTIndex]] = 0;				// unallocate the extras
		[PTBR + 2*PTIndex] = -1;
		[PTBR + 2*PTIndex + 1] = "00";
		PTIndex = PTIndex - 1;
	endwhile;
	alias counter S1;
	if (PTIndex < BBIndex) then 							// else if less, 
		counter = 0;
		alias newPageCount S8;
		newPageCount = BBIndex - PTIndex;
		while (counter < 64 && newPageCount > 0) do 							// find new free ones
			if ([MEM_LIST + counter] == 0) then
				newPageCount = newPageCount - 1;
			endif;
			counter = counter + 1;
		endwhile;	
		if (counter == 64) then								// If not enough memory, return error
			[physicalSP-2] = -1;
			ireturn;
		endif;

		counter = 0;
		newPageCount = BBIndex - PTIndex;
		while (counter < 64 && newPageCount > 0) do 
			if ([MEM_LIST + counter] == 0) then
				[MEM_LIST + counter] = 1;
				[PTBR + (BBIndex - newPageCount)*2] = counter;
				[PTBR + (BBIndex - newPageCount)*2 + 1] = "01";
				newPageCount = newPageCount - 1;
			endif;
			counter = counter + 1;
		endwhile;
	endif;

	BBIndex = 0;



	//alias counter 
	counter = 0;
	while (counter < BBIndex) do
		load([PTBR + counter*2], [SCRATCHPAD + counter]);
		counter = counter + 1;
	endwhile;

	counter = 0;
	while(counter < 8) do 
		if([currPCB + 15 + 2*counter] != -1) then			// close all files opened by current process
			[FILE_TABLE + [currPCB + 15 + 2*counter]+1] = [FILE_TABLE + [currPCB + 15 + 2*counter]+1] - 1;
			if([FILE_TABLE+[currPCB+15+2*counter]+1]==0) then 
				[FILE_TABLE + [currPCB + 15 + 2*counter]] = -1;
			endif;
			[currPCB+15+2*counter] = -1;
			[currPCB+15+2*counter+1] = 0;					// similar to what we've done in 
		endif;												// file closing
		counter = counter + 1;
	endwhile;

	SP = 3*512;
	alias newPhysicalSP S7;

	newPhysicalSP = ([PTBR+2-*(SP/512)]*512) + (SP % 512);								// new physical sp is reset to base

	[newPhysicalSP] = 0;									// pust IP in stack's top
	ireturn;
endif;

if (sysCallNo == 11) then									// sysCallNo = 11 => get current PID
	[physicalSP-2] = (PTBR - 1024)/8;
	ireturn;
endif;

if (sysCallNo == 12) then									// sysCallNo = 12 => get parent PID
	[physicalSP-2] = [currPCB+31];
	ireturn;
endif;